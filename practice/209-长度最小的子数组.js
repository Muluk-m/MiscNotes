/*
给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

 

示例 1：

输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。

示例 2：

输入：target = 4, nums = [1,4,4]
输出：1
示例 3：

输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0

 */
/**
 * 解题思路
 * 1.滑动窗口可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口
 * 2.窗口就是满足其和 ≥ target 的长度最小的连续子数组；窗口的起始位置如何移动：如果当前窗口的值大于target了，窗口就要向前移动了（也就是该缩小了）；窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针
 * 3.窗口的起始位置初始化为数组的起始位置即可
 */
var minSubArrayLen = function (target, nums) {


  const len = nums.length
  let r = 0,
    l = 0,
    optimal = len + 1, // 初始值为越界
    sum = 0
  while (r < len) {
    sum += nums[r++] // 7
    while (sum >= target) { // 满足条件
      // 判断此次窗口结果是否为最优，如果是保留，不是被更优覆盖
      res = res < r - l ? res : r - l  // 3
      sum -= nums[l++] // 左指针移动，并且调整起始位置，去除原指针位置对应的值

      // 如果依然满足条件 则继续执行逻辑，如果不满足，则拓展窗口，既移动右指针
    }
  }
  // 如果数据中所有中所有值加起来都不大于target 则r为越界既 res > len 则返回0
  return res > len ? 0 : r - l
};
