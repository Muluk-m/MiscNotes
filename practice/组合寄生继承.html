<script>
  /**
   * 寄生组合继承
   * 核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，
   * 就不会初始化两次实例方法/属性，避免的组合继承的缺点
  */
  function Cat(name) {
    Animal.call(this);
    this.name = name || 'Tom';
  }
  (function () {
    // 创建一个没有实例方法的类
    var Super = function () {};
    Super.prototype = Animal.prototype;
    //将实例作为子类的原型
    Cat.prototype = new Super();
  })();

  // Test Code
  var cat = new Cat();
  console.log(cat.name);
  console.log(cat.sleep());
  console.log(cat instanceof Animal); // true
  console.log(cat instanceof Cat); //true

  Cat.prototype.constructor = Cat; // 需要修复下构造函数

  /**
   * class extends 核心实现
   */
  function _inherits(subType, superType) {
    // 创建对象，创建父类原型的一个副本
    // 增强对象，弥补因重写原型而失去的默认的constructor 属性
    // 指定对象，将新创建的对象赋值给子类的原型
    subType.prototype = Object.create(superType && superType.prototype, {
      constructor: {
        value: subType,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });

    if (superType) {
      Object.setPrototypeOf
        ? Object.setPrototypeOf(subType, superType)
        : (subType.__proto__ = superType);
    }
  }
</script>
